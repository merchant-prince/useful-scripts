#! /usr/bin/env python


"""
Imports
"""
import re
import os
import sys
import stat
import argparse
from subprocess import run



"""
Classes
"""


class cd:
    """
    This class is a context manager to change directory.
    """

    def __init__(self, newpath):
        self.oldpath = os.getcwd()
        self.newpath = newpath
        self.pathdiff = os.path.relpath(self.oldpath, os.path.abspath(self.newpath))

    def __enter__(self):
        os.chdir(self.newpath)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.oldpath)


class Color:
    """
    This is a utility class to store the color codes used in the Print
    class.
    """

    # Bright green
    SUCCESS = {
        "HEADER":  "\033[40;38;5;82m",
        "MESSAGE": "\033[30;48;5;82m"
    }

    # Cyan
    INFO = {
        "HEADER":  "\033[40;38;5;4m",
        "MESSAGE": "\033[30;48;5;4m"
    }

    # Yellow
    WARNING = {
        "HEADER":  "\033[40;38;5;220m",
        "MESSAGE": "\033[30;48;5;220m"
    }

    # Bright Red
    ERROR = {
        "HEADER":  "\033[40;38;5;9m",
        "MESSAGE": "\033[30;48;5;9m"
    }

    # Green
    OK = "\033[32m"

    # Red
    FAIL = "\033[91m"

    RESET = "\033[0m"


class Print:
    """
    This class is used to pretty-print messages
    """

    @staticmethod
    def success(message):
        """Prints a coloured success message"""

        print(Print.__line(Color.SUCCESS['HEADER'], "Success", Color.SUCCESS['MESSAGE'], message), end='')

    @staticmethod
    def info(message):
        """Prints a coloured info message"""

        print(Print.__line(Color.INFO['HEADER'], "Info", Color.INFO['MESSAGE'], message), end='')

    @staticmethod
    def warning(message):
        """Prints a coloured warning message"""

        print(Print.__line(Color.WARNING['HEADER'], "Warning", Color.WARNING['MESSAGE'], message), end='')

    @staticmethod
    def error(message):
        """Prints a coloured error message"""

        print(Print.__line(Color.ERROR['HEADER'], "Error", Color.ERROR['MESSAGE'], message), end='')

    @staticmethod
    def ok():
        """Prints a coloured ok message"""

        print(f"{Color.OK} ...Ok {Color.RESET}", end='')

    @staticmethod
    def fail():
        """Prints a coloured ok message"""

        print(f"{Color.FAIL} ...Failed {Color.RESET}", end='')

    @staticmethod
    def eol(count=1):
        """Prints an end of line character"""

        print('\n' * count, end='')

    @staticmethod
    def __header(color, header):
        """Returns a pretty-string of the header"""

        return f"{color} {header}: {Color.RESET}"

    @staticmethod
    def __message(color, message):
        """Returns a pretty-string of the message"""

        return f"{color}\ue0b0 {message} {Color.RESET}"

    @staticmethod
    def __line(headerColor, header, messageColor, message):
        """Returns a pretified line"""

        return f"{Print.__header(headerColor, header)}{Print.__message(messageColor, message)}"


"""
Variables
"""


projectName = "One"
projectUri = "dev.local"
userId = os.geteuid()
groupId = os.getegid()
ssl = {
        'path': '/etc/nginx/ssl',
        'key': 'key.pem',
        'cert': 'cert.pem'
}
server = {
        'root': '/var/www/html'
}
php = {
        'port': 9000
}
database = {
        'name': 'application',
        'username': 'username',
        'password': 'password'
}


"""
Pre-Installation
"""


def check_project_name():
    Print.info("Checking project name")

    projectNameIsPascalCased = bool(re.match('^[A-Z][a-z]+(?:[A-Z][a-z]+)*$', projectName))

    if projectNameIsPascalCased:
        Print.ok()
        Print.eol(2)
    else:
        Print.fail()
        Print.eol(2)
        Print.error("The project name is not pascal-cased")
        Print.eol()
        sys.exit(1)


def check_project_existence():
    Print.info("Checking project existence within current directory")

    projectExists = os.path.isdir(projectName) if projectName in os.listdir() else False

    if not projectExists:
        Print.ok()
        Print.eol(2)
    else:
        Print.fail()
        Print.eol(2)
        Print.error("Another project with the same name already exists in this directory")
        Print.eol()
        sys.exit(1)


"""
Installation
"""


def define_directory_structure():
    Print.info("Creating directory structure of project")

    os.mkdir(projectName)

    with cd(projectName):
        os.mkdir("configuration")

        with cd("configuration"):
            os.mkdir("nginx")

        os.mkdir("certificate")

        with cd("certificate"):
            os.mkdir("ssl")

        os.mkdir("dockerfile")

        with cd("dockerfile"):
            os.mkdir("php")

        os.mkdir("application")

    Print.ok()
    Print.eol(2)


def goto_project_root():
    Print.info("Going to project root")

    os.chdir(projectName)

    Print.ok()
    Print.eol(2)


def generate_ssl_certificates():
    with cd("certificate/ssl"):
        workingDirectory = "/certificates"
        imageName = "harivansh/laravel-docker-openssl"
        dockerfile = f"""\
ARG TAG=latest

FROM debian:${{TAG}}

RUN apt-get update && apt-get install -y openssl

WORKDIR {workingDirectory}

VOLUME {workingDirectory}

ENTRYPOINT ["openssl"]
"""

        Print.info("Creating docker openssl image")
        Print.eol(2)

        process = run([
            "docker", "build", "--tag", imageName,
                               "-"
        ], input=dockerfile, encoding="ascii", check=True)

        Print.eol()
        Print.success("Created docker openssl image")
        Print.eol(2)


        Print.info("Generating ssl certificates")
        Print.eol(2)

        run(["docker", "run", "--rm",
                              "--interactive",
                              "--tty",
                              "--mount", f"type=bind,source={os.getcwd()},target={workingDirectory}",
                              "--user", f"{userId}:{groupId}",
                              imageName, "req", "-x509",
                                                "-newkey",
                                                "rsa:4096",
                                                "-keyout", ssl['key'],
                                                "-out", ssl['cert'],
                                                "-days", "365",
                                                "-nodes",
                                                "-sha256",
                                                "-subj", ("/C=MU"
                                                          "/ST=Pamplemousses"
                                                          "/L=Piton"
                                                          "/O=Redshift"
                                                          "/OU=IT"
                                                          f"/CN={projectUri}")
        ], check=True)

        Print.eol()
        Print.success("SSL certificates generated")
        Print.eol(2)


def generate_nginx_configuration():
    with cd("configuration/nginx"):
        defaultConf = f"""\
server {{
    listen 80 default_server;
    server_name {projectUri};

    return 301 https://$server_name$request_uri;
}}

server {{
    listen 443 ssl;
    server_name {projectUri};

    ssl_certificate {ssl['path'] + '/' + ssl['cert']};
    ssl_certificate_key {ssl['path'] + '/' + ssl['key']};

    root {server['root']}/public;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";

    index index.html index.htm index.php;

    charset utf-8;

    location / {{
        try_files $uri $uri/ /index.php?$query_string;
    }}

    location = /favicon.ico {{ access_log off; log_not_found off; }}
    location = /robots.txt  {{ access_log off; log_not_found off; }}

    error_page 404 /index.php;

    location ~ \.php$ {{
        fastcgi_pass php:{php['port']};
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        include fastcgi_params;
    }}

    location ~ /\.(?!well-known).* {{
        deny all;
    }}
}}
"""

        Print.info("Generating nginx configuration file")

        with open('default.conf', 'w') as conf:
            conf.write(defaultConf)

        Print.ok()
        Print.eol(2)


def generate_php_dockerfile():
    with cd("dockerfile/php"):
        dockerfile = f"""\
ARG TAG=latest

FROM php:${{TAG}}

RUN apt-get update \\
 && apt-get install -y libpq-dev \\
 && docker-php-ext-configure pgsql \\
 && docker-php-ext-install pdo_pgsql pgsql pcntl \\
 && pecl install redis \\
 && docker-php-ext-enable redis \\
 && rm -rf /var/lib/apt/lists/*

RUN mv "${{PHP_INI_DIR}}/php.ini-development" "${{PHP_INI_DIR}}/php.ini"

###
# Change the UID and GID of the www-data so that there are no
# permission conflicts on the files manipulated by the container
# on the host.
###

ARG USER_ID={userId}
ARG GROUP_ID={groupId}

RUN userdel -f www-data && \\
    if getent group www-data; \\
    then \\
      groupdel www-data; \\
    fi && \\
    groupadd -g ${{GROUP_ID}} www-data && \\
    useradd -l -u ${{USER_ID}} -g www-data www-data && \\
    install -d -m 0755 -o www-data -g www-data /home/www-data && \\
    chown --changes \\
          --silent \\
          --no-dereference \\
          --recursive \\
          --from=33:33 \\
          ${{USER_ID}}:${{GROUP_ID}} \\
            /home/www-data
        
USER www-data
"""

        Print.info("Generating php dockerfile")

        with open("Dockerfile", "w") as phpDockerfile:
            phpDockerfile.write(dockerfile)

        Print.ok()
        Print.eol(2)


def generate_docker_compose():
    dockerCompose = f"""\
version: '3.7'

services:
    nginx:
        image: nginx:latest
        container_name: nginx
        volumes:
            - ./configuration/nginx/default.conf:/etc/nginx/conf.d/default.conf
            - ./application/{projectName}:{server['root']}
            - ./certificate/ssl:{ssl['path']}
        ports:
            - "80:80"
            - "443:443"
        depends_on:
            - php
        networks:
            - application

    php:
        build:
            context: ./dockerfile/php
            args:
                - TAG=fpm
                - USER_ID={userId}
                - GROUP_ID={groupId}
        container_name: php
        volumes:
            - ./application/{projectName}:{server['root']}
        depends_on:
            - postgresql
            - redis
        networks:
            - application
            - database
            - redis

    postgresql:
        image: postgres:latest
        container_name: postgresql
        volumes:
            - database:/var/lib/postgresql/data
        environment:
            POSTGRES_DB: "{database['name']}"
            POSTGRES_USER: "{database['username']}"
            POSTGRES_PASSWORD: "{database['password']}"
        networks:
            - database

    redis:
        image: redis:latest
        container_name: redis
        volumes:
            - redis:/data
        networks:
            - redis

networks:
    application:
    database:
    redis:

volumes:
    database:
    redis:
"""

    Print.info("Generating docker-compose file")

    with open("docker-compose.yml", "w") as compose:
        compose.write(dockerCompose)

    Print.ok()
    Print.eol(2)


def generate_run_binary():
    binary = f"""\
#! /usr/bin/env python

import os
import sys
import argparse
from subprocess import run


parser = argparse.ArgumentParser(description="Perform common tasks on the laravel-docker stack")

parser.add_argument("action", help="Define an action to take on the stack / application",
                    choices=("artisan", "composer", "yarn", "phpunit"))
parser.add_argument("options", nargs=argparse.REMAINDER, help="Optional arguments to pass to the specified action")

primary = parser.parse_args()

if primary.action == "artisan":
    run(["docker-compose", "exec", "php", "php", "artisan"] + primary.options)

elif primary.action == "composer":
    run([
        "docker", "run", "--rm",
                         "--interactive",
                         "--tty",
                         "--user", "{userId}:{groupId}",
                         "--workdir", "/application",
                         "--mount", f"type=bind,source={{os.getcwd()}}/application/{projectName},target=/application",
                         "composer"] + primary.options)

elif primary.action == "yarn":
    run([
        "docker", "run", "--rm",
                         "--interactive",
                         "--tty",
                         "--user", "{userId}:{groupId}",
                         "--workdir", "/application",
                         "--mount", f"type=bind,source={{os.getcwd()}}/application/{projectName},target=/application",
                         "node", "yarn"] + primary.options)

elif primary.action == "phpunit":
    run(["docker-compose", "exec", "php", "php", "./vendor/bin/phpunit"] + primary.options)
"""

    Print.info("Generating run binary")

    with open("run", "w") as run:
        run.write(binary)

    run = os.stat("run")

    os.chmod("run", run.st_mode | stat.S_IEXEC)

    Print.ok()
    Print.eol(2)


def install_laravel_framework():
    Print.info("Pulling fresh laravel application")
    Print.eol(2)

    with cd("application"):
        workdir = "/application"

        run([
            "docker", "run", "--rm",
                             "--interactive",
                             "--tty",
                             "--user", f"{userId}:{groupId}",
                             "--workdir", workdir,
                             "--mount", f"type=bind,source={os.getcwd()},target={workdir}",
                             "composer", "create-project", "--prefer-dist",
                                                           "--ignore-platform-reqs",
                                                           "laravel/laravel", projectName
        ])

        Print.eol()
        Print.success("Pulled fresh laravel application")
        Print.eol(2)


def initialize_git_repository_for_project():
    Print.info("Initializing git repository for project")

    with cd(f"application/{projectName}"):
        run(["git", "init"])
        run(["git", "add", "."])
        run(["git", "commit", "-m", "initial commit"])
        run(["git", "checkout", "-b", "development"])

    Print.ok()
    Print.eol(2)


"""
Post-Installation
"""


def edit_env_file():
    # Get the application key

    key = None

    with cd(f"application/{projectName}"):
        with open(".env") as env:
            for line in env:
                if re.search("APP_KEY", line):
                    key = re.findall("APP_KEY=(.*)", line.strip())[0]
                    break

        dotEnv = f"""\
APP_NAME={projectName}
APP_ENV=local
APP_KEY={key}
APP_DEBUG=true
APP_URL=https://{projectUri}

LOG_CHANNEL=stack

DB_CONNECTION=pgsql
DB_HOST=postgresql
DB_PORT=5432
DB_DATABASE={database['name']}
DB_USERNAME={database['username']}
DB_PASSWORD={database['password']}

REDIS_CLIENT=phpredis
REDIS_HOST=redis
REDIS_PORT=6379

BROADCAST_DRIVER=log

CACHE_DRIVER=redis

QUEUE_CONNECTION=redis

SESSION_DRIVER=redis

MAIL_DRIVER=smtp
MAIL_SERVER=smtp.mailtrap.io
MAIL_PORT=2525
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
"""

        with open(".env", "w") as env:
            env.write(dotEnv)


"""
Run
"""

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="A script to automate the installation of a Laravel project, and its stack")

    subparsers = parser.add_subparsers(dest="actions")

    new_command = subparsers.add_parser("new", help="Install a new laravel application in the current directory")
    new_command.add_argument("name", help="The project name (should be PascalCased)")

    arguments = parser.parse_args()

    if arguments.actions == "new":
        projectName = arguments.name

        check_project_name()
        check_project_existence()

        define_directory_structure()

        goto_project_root()

        generate_ssl_certificates()
        generate_nginx_configuration()
        generate_php_dockerfile()
        generate_docker_compose()
        generate_run_binary()

        install_laravel_framework()

        initialize_git_repository_for_project()

        edit_env_file()
